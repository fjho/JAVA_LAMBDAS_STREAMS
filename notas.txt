- Lambda expressions
    - Forma de implementar una clase anónima con menos código
    - Es un método anónimo que se puede pasar a otros métodos
    - Sintaxis
        (parameter list) arrow body
        
        Sin arrow function:
        products.sort(new java.util.Comparator<Product>() {
            @Override
            public int compare(Product p1, Product p2) {
            return p1.getPrice().compareTo(p2.getPrice()); <----------------la lógica de la arrow function es sólo una linea
            }
        });
        
        Si la lógica de la arrow function es sólo una linea se puede escribir así:
        
        (p1, p2) -> p1.getPrice().compareTo(p2.getPrice()
        
        Si la lógica de la arrow function es más de una línea se tiene que escribir así:
        
        (p1,p2) -> {
            return p1.getPrice().compareTo(p2.getPrice());
        }
        
        En este caso se está implementando la interfaz 'Comparator' su metodo 'compare' que recibe dos parametros y devuelve un int
        Se puede especificar el tipo de los parametros aunk no se suele hacer (ya está especificado en la functional interface que implementa):
        (Product p1, Product p2) -> p1.getPrice().compareTo(p2.getPrice()
        
        Runnable runnable = () -> System.out.println("Hello");
        En este caso se está implementando la interfaz 'Runnable' su metodo 'run' no recibe parametros y no devuelve nada
        
        FileFilter filter = file -> file.getName().endsWith(".java");
        En este caso se está implementando la interfaz 'FileFilter' su método 'accept' que sólo recibe un parametro y devuelve un bool
        

- Functional interfaces
    - Son interfaces que tienen un sólo método abstracto para implementar y que se implementaban con una clase anónima
    - Una lambda expresion siempre implementa una functional interface
    - En el paquete java.util.function hay definidas muchas funciones anonimas
    


